# Диаграмма компонентов

![alt](img/components.svg)

Вся программная реализация располагается в глобальном компоненте _game_.

# Диаграмма классов

[Ссылка](img/everything.svg) на полную диаграмму классов.

# Поток управления игры

Точка входа в игру находится в классе верхнего уровня **Game** в методе _main_. В нем хранится **GameState**, который согласно паттерну _Состояние_ использует несколько классов для разных состояний игры. Диаграмма состояний представителей **GameState** изображена ниже:

![alt](img/game-states.png)

В каждом состоянии определяются методы _processInput_, _update_ и _draw_, реализующие соответствующие активности. _processInput_ использует класс **Keyboard**, в который состояние игры при инициализации скалывает команды для управления, которые созданы управляемыми обьектами. Например, в состоянии с меню (Game menu) будет помещено управление (**Controls**) которое при нажатии кнопки "вниз" выберет следующий пункт меню. Во время игры добавится **Controls** от класса **Player**, которое передвигает персонажа и атакует мобов.

Класс **GameInfo** содержит общие обьекты для состояний **Play game**, **Pause** и **Inventory**, а именно те данные, которые сохраняются между состояниями: список существ, карта и контроллеры движений и атак.

Диаграмма классов состояний игры изображена ниже:

## Процесс игры. Паттерн Game loop

Сама игра работает согласно паттерну [_Game loop_](https://gameprogrammingpatterns.com/game-loop.html), то есть в цикле вызываются три функции текущего состояния игры:

```kotlin
state.processInput();
state.update();
state.draw();
```

Которые делают следующее:

- _processInput_ - принимают управление от пользователя и исполняют его
- _update_ - обновляет игровые сущности, просчитывает поведение, передвижение и атаки мобов
- _draw_ - отрисовывает карту и персонажей

### Метод update

Обновление мобов с помощью обращения к медиаторам (контроллерам) передвижения и атаки. Контроллер передвижения обновит передвижение мобов, проверит, что они не сталкиваются, и, что они умирают, если провалятся в пропасть или лаву. Контроллер атаки вызывает атаки мобов, наносит им повреждения, и, в случае смерти, убивает моба и передает экспу и лут убийце.

Для обновления поведения в обоих случаях персонажам передается окрестность карты и ближайшие существа, передаваемые в _update_. Внутри существо содержит состояние, в котором находится моб, и стратегию, определяющую его поведение в этом состоянии.

### Метод draw

Метод _draw_ просто отрисовывает карту и персонажей:

```kotlin
map.draw();
for (creature : this.creatures)
    creature.draw();
```

## Генерация игры

Генерация игры происходит в состоянии **New game**. Для генерации лута из каждого моба используется класс **LootDirector**, работающий с абстрактной фабрикой лута. Для генерации карты же используется класс **MapGenerator**, генерирующий карту, состоящую из тайлов, по которым будут двигаться персонажи. Мобы генерируются с помощью абстрактной фабрики **AbstractMobFactory**, которая принимает параметры моба (тип атаки, передвижения и т.д.) и создает моба из некого семейства (например зомби или скелета) с соответствующими характеристиками.

## Характеристики мобов

Все существа (а именно игрок и мобы) наследуются от абстрактного класса **Creature**, который содержит методы _update_ и _draw_ для обеспечения работы паттерна _Game loop_. В качестве полей, **Creature** содержит свои координаты и статы.

Для реализации статов используется паттерн _Мост_, в котором абстракция - тип моба, а реализация - его характеристики. На схеме в пункте _Статы мобов_ в качестве примера приведены разные виды характеристики атаки (**MeleeAttack** и **RangeAttack**) и передвижения (**WalkMovement** и **FlyMovement**). В качестве примеров конкретных фабрик в схеме выше приведены две фабрики мобов - зомби **ZombieFactory** и скелетов **SkeletonFactory**, соответствующие продукты - наследники абстрактного продукта **AbstractMob**: зомби **Zombie** и скелет **Skeleton**.

## Система прокачки

Для хранения и работы с уровнем игрока выделен отдельный класс **Level**, в котором хранятся:

- _currentXP_ - текущее количество опыта на новый уровень
- _neededXP_ - нужное количество уровня для левелапа
- _level_ - текущий уровень

Влияние опыта и предметов на характеристики персонажа учитывается с помощью применения методов `Equipment.apply(stats)` и метода `Level.apply(stats)`, учитывающего уровень персонажа.

## Карта

Карта представляет собой таблицу, состоящую из тайлов (вода, земля или стена). Она предоставляет методы для отрисовки себя и получения тайлов окрестности существа, чтобы эмулировать возможность видеть. Класс **MapGenerator** реализует алгоритм генерации карты, используемый в **NewGameState**.
